#!/usr/bin/python
# -*- coding: utf-8 -*-

"""audioidmon_batch_monitoring: Script does batch monitoring of recordings generation."""

__author__  = 'Lars Fabig'
__date__    = '15.08.2016'
__email__   = 'lfabig@mufin.com'
__docformat__ = 'reStructuredText'


# Standard library imports ...
import argparse
import codecs
import csv
import json
import os
import os.path
import pkg_resources
import shutil
import sys

# Third-party imports ...
import yaml

# Local imports ...
import audioidmon
import audioidmon.utils


# Constants
input_file_formats = ['*.*']


# Init command line parser
parser = argparse.ArgumentParser(prog='audioidmon_batch_monitoring', description="Batch monitoring of recordings. The applications reads reference and recording audio files from two specified folders. It scans these folders for the audio files (*.wav, *.mp3, *.ts) and copies the files to the specified project folder. Afterwards the fingerprints are extracted and then the recordings are monitored. The results are stored in a subfolder 'reports' of the project in three different formats. Supported are CSV, YAML and JSON. If the process is interrupted for some reason you may restart over again to process the remaining files.")
parser.add_argument('host_address', help='host address of audioid monitor service, e.g. http://127.0.0.1 [string]')
parser.add_argument('project_directory', help='root directory where the project related data shall be stored [string]')
parser.add_argument('references_source_directory', help='directory where the references (audio or fingerprints) are located [string]')
parser.add_argument('recordings_source_directory', help='directory where the recordings (audio or fingerprints) are located [string]')
parser.add_argument('-c', '--copy', help='copy reference and recording audio files to project folder', action='store_true')
parser.add_argument('-v', '--verbose', help='increase output verbosity', action='store_true')
parser.add_argument('--version', help='print version number', action='version', version='%(prog)s {}'.format(pkg_resources.get_distribution('pyaudioidmon').version))


def main():
    # parsing command line options
    args = parser.parse_args()
    if not audioidmon.utils.validate_url(args.host_address):
        parser.error("invalid host url '{}'".format(args.host_address))
    # print input parameter
    if args.verbose:
        print "Batch report generation:"
        print "  Project directory            : '%s'" % args.project_directory
        print "  References source directory  : '%s'" % args.references_source_directory
        print "  Recordings source directory  : '%s'" % args.recordings_source_directory
        print "  Host address                 : '%s'" % args.host_address

    try:
        # Setup project directory
        if args.verbose:
            print "  Setting up project directory ..."
        project_path = os.path.abspath(args.project_directory)
        references_audio_path = os.path.join("references", "audio")
        references_fingerprint_path = os.path.join("references", "fingerprint")
        recordings_audio_path = os.path.join("recordings", "audio")
        recordings_fingerprint_path = os.path.join("recordings", "fingerprint")
        reports_csv_path = os.path.join("reports", "csv")
        reports_yaml_path = os.path.join("reports", "yaml")
        reports_js_path = os.path.join("reports", "json")

        audioidmon.utils.ensuredirs(os.path.join(project_path, references_audio_path))
        audioidmon.utils.ensuredirs(os.path.join(project_path, references_fingerprint_path))
        audioidmon.utils.ensuredirs(os.path.join(project_path, recordings_audio_path))
        audioidmon.utils.ensuredirs(os.path.join(project_path, recordings_fingerprint_path))
        audioidmon.utils.ensuredirs(os.path.join(project_path, reports_csv_path))
        audioidmon.utils.ensuredirs(os.path.join(project_path, reports_yaml_path))
        audioidmon.utils.ensuredirs(os.path.join(project_path, reports_js_path))
        # Scan for references
        if args.verbose:
            print "  Search for references %s in '%s' ..." % (input_file_formats, args.references_source_directory)
        references_by_ext = audioidmon.utils.search_files(args.references_source_directory, input_file_formats, recursive=True)
        references = []
        for rlist in references_by_ext:
            references += rlist
        references.sort()
        if args.verbose:
            print "    %s references found." % len(references)
        if len(references) == 0:
            print "    [Warning] %s references found. Stopped." % len(references)
            sys.exit(1)
        if args.verbose:
            for r in references:
                print "    %s" % r

        # Scan for recordings
        if args.verbose:
            print "  Search for recordings %s in '%s' ..." % (input_file_formats, args.recordings_source_directory)
        recordings_by_ext = audioidmon.utils.search_files(args.recordings_source_directory, input_file_formats, recursive=True)
        recordings = []
        for rlist in recordings_by_ext:
            recordings += rlist
        recordings.sort()
        if args.verbose:
            print "    %s recordings found." % len(recordings)
        if len(recordings) == 0:
            print "    [Warning] %s recordings found. Stopped." % len(recordings)
            sys.exit(1)
        if args.verbose:
            for r in recordings:
                print "    %s" % r

        # Copy reference source files to project folder
        if args.copy:
            if args.verbose:
                print "  Copy references to project folder ..."
            references_list = []
            for r in references:
                dest = os.path.join(references_audio_path, os.path.basename(r))
                if args.verbose:
                    sys.stdout.write("    %s -> %s ... " % (r, dest))
                if not os.path.exists(os.path.join(project_path, dest)):
                    shutil.copyfile(r, os.path.join(project_path, dest))
                    if args.verbose:
                        sys.stdout.write("done.\n")
                else:
                    if args.verbose:
                        sys.stdout.write("exists.\n")
                references_list.append(dest)
            references_list.sort()
        else:
            references_list = references

        # Create list of reference files in project folder
        if args.verbose:
            sys.stdout.write("  Write references file list into project folder ... ")
            sys.stdout.flush()
        outfile = open(os.path.join(args.project_directory, "references.lst"), "w")
        for filename in references_list:
            outfile.write("%s\n" % filename)
        outfile.close()
        if args.verbose:
            sys.stdout.write("done.\n")

        # Copy recording source files to project folder
        if args.copy:
            if args.verbose:
                print "  Copy recordings to project folder ..."
            recordings_list = []
            for r in recordings:
                dest = os.path.join(recordings_audio_path, os.path.basename(r))
                if args.verbose:
                    sys.stdout.write("    %s -> %s ... " % (r, dest))
                    sys.stdout.flush()
                if not os.path.exists(os.path.join(project_path, dest)):
                    shutil.copyfile(r, os.path.join(project_path, recordings_audio_path, os.path.basename(r)))
                    if args.verbose:
                        sys.stdout.write("done.\n")
                else:
                    if args.verbose:
                        sys.stdout.write("exists.\n")
                recordings_list.append(dest)
            recordings_list.sort()
        else:
            recordings_list = recordings

        # Create list of recording files in project folder
        if args.verbose:
            sys.stdout.write("  Write recordings file list into project folder ... ")
            sys.stdout.flush()
        outfile = open(os.path.join(project_path, "recordings.lst"), "w")
        for filename in recordings_list:
            outfile.write("%s\n" % filename)
        outfile.close()
        if args.verbose:
            sys.stdout.write("done.\n")

        # Read references list
        references_list = []
        infile = open(os.path.join(project_path, "references.lst"), "r")
        references_list = infile.read().splitlines()
        infile.close()

        # Init audioid monitor client
        if args.verbose:
            print "  Init audioidmon client ..."
        am = audioidmon.AudioidMonService(args.host_address)

        # Extract reference fingerprints
        if args.verbose:
            print "  Extract references fingerprints ..."
        num_refs=1
        for source in references_list:
            dest, ext = os.path.splitext(source)
            dest += ".mfp"
            dest = os.path.join(project_path, references_fingerprint_path, os.path.basename(dest))
            if args.copy:
                source = os.path.join(project_path, source)
            else:
                source = os.path.abspath(source)
            if args.verbose:
                sys.stdout.write("    [%s/%s] %s -> %s ... " % (num_refs, len(references_list), source, dest))
                sys.stdout.flush()
            if not os.path.exists(os.path.join(project_path, references_fingerprint_path, os.path.basename(dest))):
                try:
                    if args.copy:
                        am.extract_fingerprint(source, dest)
                    else:
                        am.extract_fingerprint(os.path.join(project_path, source), dest)
                    if args.verbose:
                        sys.stdout.write("done.\n")
                except Exception:
                    if args.verbose:
                        sys.stdout.write("failed.\n")
            else:
                if args.verbose:
                    sys.stdout.write("exists.\n")
            num_refs += 1

        # Read recording list
        recordings_list = []
        infile = open(os.path.join(project_path, "recordings.lst"), "r")
        recordings_list = infile.read().splitlines()
        infile.close()


        # Extract recording fingerprints
        if args.verbose:
            print "  Extract recording fingerprints ..."
        num_recs=1
        for source in recordings_list:
            dest, ext = os.path.splitext(source)
            dest += ".mfp"
            dest = os.path.join(project_path, recordings_fingerprint_path, os.path.basename(dest))
            if args.copy:
                source = os.path.join(project_path, source)
            else:
                source = os.path.abspath(source)
            if args.verbose:
                sys.stdout.write("    [%s/%s] %s -> %s ... " % (num_recs, len(recordings_list), source, dest))
                sys.stdout.flush()
            if not os.path.exists(os.path.join(project_path, recordings_fingerprint_path, os.path.basename(dest))):
                try:
                    if args.copy:
                        am.extract_fingerprint(source, dest)
                    else:
                        am.extract_fingerprint(os.path.join(project_path, source), dest)
                    if args.verbose:
                        sys.stdout.write("done.\n")
                except Exception:
                    sys.stdout.write("failed.\n")
            else:
                if args.verbose:
                    sys.stdout.write("exists.\n")
            num_recs += 1

        # Search for reference fingerprints
        path = os.path.join(project_path, references_fingerprint_path)
        if args.verbose:
            sys.stdout.write("  Get reference fingerprints '*.mfp' in '%s' ... " % references_fingerprint_path)
            sys.stdout.flush()
        references = audioidmon.utils.search_files(path, ["*.mfp"], recursive=True)
        references[0].sort()
        if args.verbose:
            sys.stdout.write("done.\n")

        # Create fingerprint index and write to project directory
        path = os.path.join(project_path, "fingerprint_index.yml")
        if args.verbose:
            sys.stdout.write("  Create reference fingerprint index and store it in project '%s' ... " % path)
        fingerprint_index = []
        for index, elem in enumerate(references[0]):
            fingerprint_index.append({"id": index+1, "filename": elem})
        outfile = open(path.decode(sys.getfilesystemencoding()), "w")
        outfile.write(yaml.safe_dump(fingerprint_index, default_flow_style=False))
        outfile.close()
        if args.verbose:
            sys.stdout.write("done.\n")
            sys.stdout.flush()


        # Load fingerprint into audioid monitor service
        am.delete_fingerprints()
        if args.verbose:
            sys.stdout.write("  Load fingerprints ... ")
            sys.stdout.flush()
        for fp in fingerprint_index:
            am.add_fingerprint(fp["id"], fp["filename"])
        if args.verbose:
            sys.stdout.write("%s fingerprints loaded.\n" % str(len(am.get_fingerprint_ids())))
            sys.stdout.flush()

        # Search for recording fingerprints
        path = os.path.join(project_path, recordings_fingerprint_path)
        if args.verbose:
            sys.stdout.write("  Get recording fingerprints '*.mfp' in '%s' ... " % recordings_fingerprint_path)
            sys.stdout.flush()
        recordings = audioidmon.utils.search_files(path, ["*.mfp"], recursive=True)
        recordings[0].sort()
        if args.verbose:
            sys.stdout.write("%s recording to be processed.\n" % str(len(recordings[0])))

        # Batch monitoring of fingerprints
        if args.verbose:
            print "  Batch monitoring recording fingerprints ..."
        num_recs = 1
        for rec in recordings[0]:
            dest, ext = os.path.splitext(rec)
            dest += ".json"
            dest = os.path.join(project_path, reports_js_path, os.path.basename(dest))
            if args.verbose:
                sys.stdout.write("    [%s/%s]  monitoring '%s' -> '%s' ... " % (num_recs, len(recordings[0]), os.path.join(project_path, recordings_fingerprint_path, os.path.basename(rec)), dest))
                sys.stdout.flush()
            if not os.path.exists(dest):
                response = am.monitor_fingerprint(rec)
                report = []
                for match in response:
                    if match["referenceId"] != 0:
                        name = filter(lambda reference: reference['id'] == match["referenceId"], fingerprint_index)
                        match["referenceFilename"] = os.path.basename(name[0]["filename"])
                        report.append(match)
                # Save as report in JSON format
                outfile = open(dest.decode(sys.getfilesystemencoding()), "w")
                json.dump(report, outfile, indent=2, separators=(',', ': '))
                outfile.close()
                if args.verbose:
                    sys.stdout.write("done.\n")
            else:
                if args.verbose:
                    sys.stdout.write("exists.\n")
            num_recs += 1

        # Save as report in YAML format
        if args.verbose:
            print "  Convert JSON reports to YAML reports ..."
        json_report_list = audioidmon.utils.search_files(os.path.join(project_path, reports_js_path), ["*.json"], recursive=False)
        for json_file in json_report_list[0]:
            json_report = json.load(open(json_file.decode(sys.getfilesystemencoding()), "r"))
            dest, ext = os.path.splitext(json_file)
            dest += ".yaml"
            dest = os.path.join(project_path, reports_yaml_path, os.path.basename(dest))
            if not os.path.exists(dest):
                yaml_file = open(dest.decode(sys.getfilesystemencoding()), "w")
                yaml_file.write(yaml.safe_dump(json_report, default_flow_style=False))
                yaml_file.close()

        # Save as report in CSV format
        if args.verbose:
            print "  Convert JSON reports to CSV reports ..."
        json_report_list = audioidmon.utils.search_files(os.path.join(project_path, reports_js_path), ["*.json"], recursive=False)
        for json_file in json_report_list[0]:
            json_report = json.load(open(json_file.decode(sys.getfilesystemencoding()), "r"))
            dest, ext = os.path.splitext(json_file)
            dest += ".csv"
            dest = os.path.join(project_path, reports_csv_path, os.path.basename(dest))
            if not os.path.exists(dest.decode(sys.getfilesystemencoding())):
                csv_file = open(dest.decode(sys.getfilesystemencoding()), "w")
                writer = csv.writer(csv_file)
                writer.writerow(("referenceId", "referenceFilename", "qryStart", "qryStop", "refStart", "refStop", "confidence"))
                for match in json_report:
                    writer.writerow((match["referenceId"], codecs.encode(match["referenceFilename"], 'utf-8'), match["qryStart"], match["qryStop"], match["refStart"], match["refStop"], match["confidence"]))
                csv_file.close()
        if args.verbose:
            print "  Reports stored as CSV, YAML and JSON. Get reports from project subfolders:"
            print "    ./reports/csv/"
            print "    ./reports/yaml/"
            print "    ./reports/json/"
            print "Done."
        sys.exit(0)
    except KeyboardInterrupt:
        sys.stderr.write("\n  [Warning] Script interrupted. Not all data has been processed! You may run the script again to continue.\n")
        sys.exit(1)
    except Exception as err:
        sys.stderr.write("[Error] {} : {}\n".format(type(err).__name__, str(err)))
        sys.exit(1)


if __name__ == '__main__':
    main()
